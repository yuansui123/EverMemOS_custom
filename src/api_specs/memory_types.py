"""
Memory types module

This module contains the definitions of memory types and related data structures, just for extraction.
"""

from enum import Enum
from typing import List, Dict, Any, Optional, Union
from dataclasses import dataclass
from datetime import datetime
from common_utils.datetime_utils import to_iso_format

from api_specs.memory_models import MemoryType


class RawDataType(Enum):
    """Types of content that can be processed."""

    CONVERSATION = "Conversation"

    @classmethod
    def from_string(cls, type_str: Optional[str]) -> Optional['RawDataType']:
        """
        Convert string type to RawDataType enum

        Args:
            type_str: Type string, such as "Conversation", "Email", etc.

        Returns:
            RawDataType enum value, returns None if conversion fails
        """
        if not type_str:
            return None

        try:
            # Convert string to enum name format (e.g., "Conversation" -> "CONVERSATION")
            enum_name = type_str.upper()
            return getattr(cls, enum_name)

        except AttributeError:
            # If no matching enum is found, return None
            from core.observation.logger import get_logger

            logger = get_logger(__name__)
            logger.error(f"No matching RawDataType found: {type_str}, returning None")
            return None
        except Exception as e:
            from core.observation.logger import get_logger

            logger = get_logger(__name__)
            logger.warning(f"Failed to convert type field: {type_str}, error: {e}")
            return None


class ParentType(str, Enum):
    """Parent memory type for Foresight/EventLog."""

    MEMCELL = "memcell"
    EPISODE = "episode"


@dataclass
class MemCell:
    # TODO: Name conflict - should add BO suffix (such as MemCellBO) to distinguish between business objects and document objects
    """
    Boundary detection result following the specified schema.

    This class represents the result of boundary detection analysis
    and contains all the required fields for memory storage.
    """

    # Required fields (must come before fields with default values)
    user_id_list: List[str]
    # For downstream consumers we store normalized dicts extracted from RawData
    original_data: List[Dict[str, Any]]
    timestamp: datetime

    # Optional fields
    summary: Optional[str] = None  # Can be empty for force-split memcells
    event_id: Optional[str] = (
        None  # history question, actually is id, it will be generated by database when saving
    )
    group_id: Optional[str] = None
    group_name: Optional[str] = None
    participants: Optional[List[str]] = None
    type: Optional[RawDataType] = None
    keywords: Optional[List[str]] = None
    subject: Optional[str] = None
    linked_entities: Optional[List[str]] = None
    episode: Optional[str] = None  # episodic memory content

    # Prospective association prediction field
    foresights: Optional[List['Foresight']] = None  # list of prospective associations
    # Event Log field
    event_log: Optional[Any] = None  # Event Log object
    # extend fields, can be used to store any additional information
    extend: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        """Validate the result after initialization."""
        if not self.original_data:
            raise ValueError("original_data is required")

    def __repr__(self) -> str:
        return f"MemCell(event_id={self.event_id!r}, original_data={self.original_data!r}, timestamp={self.timestamp!r}, summary={self.summary!r})"

    def to_dict(self) -> Dict[str, Any]:
        return {
            "event_id": self.event_id if self.event_id else None,
            "user_id_list": self.user_id_list,
            "original_data": self.original_data,
            "timestamp": to_iso_format(self.timestamp),  # convert to ISO format string
            "summary": self.summary,
            "group_id": self.group_id,
            "group_name": self.group_name,
            "participants": self.participants,
            "type": str(self.type.value) if self.type else None,
            "keywords": self.keywords,
            "linked_entities": self.linked_entities,
            "subject": self.subject,
            "episode": self.episode,
            "foresights": (
                [item.to_dict() for item in self.foresights]
                if self.foresights
                else None
            ),
            "event_log": (
                (
                    self.event_log.to_dict()
                    if hasattr(self.event_log, 'to_dict')
                    else self.event_log
                )
                if self.event_log
                else None
            ),
            "extend": self.extend,
        }


@dataclass
class BaseMemory:
    """
    Base class for all memory types.
    Contains common fields shared by all memory types.
    """

    memory_type: MemoryType
    user_id: str
    timestamp: datetime
    ori_event_id_list: List[str]

    group_id: Optional[str] = None
    group_name: Optional[str] = None
    participants: Optional[List[str]] = None
    type: Optional[RawDataType] = None
    keywords: Optional[List[str]] = None
    linked_entities: Optional[List[str]] = None

    memcell_event_id_list: Optional[List[str]] = None
    user_name: Optional[str] = None
    extend: Optional[Dict[str, Any]] = None

    # vector and model
    vector_model: Optional[str] = None
    vector: Optional[List[float]] = None

    # ID field for retrieval
    id: Optional[str] = None

    def _format_timestamp(self) -> Optional[str]:
        """Format timestamp to ISO string"""
        if not self.timestamp:
            return None
        if isinstance(self.timestamp, str):
            return self.timestamp if self.timestamp else None
        try:
            return to_iso_format(self.timestamp)
        except Exception:
            return str(self.timestamp) if self.timestamp else None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "memory_type": self.memory_type.value if self.memory_type else None,
            "user_id": self.user_id,
            "user_name": self.user_name,
            "timestamp": self._format_timestamp(),
            "ori_event_id_list": self.ori_event_id_list,
            "group_id": self.group_id,
            "group_name": self.group_name,
            "participants": self.participants,
            "type": self.type.value if self.type else None,
            "keywords": self.keywords,
            "linked_entities": self.linked_entities,
            "extend": self.extend,
        }


@dataclass
class EpisodeMemory(BaseMemory):
    """Episode memory - narrative memory of events."""

    id: Optional[str] = None
    subject: Optional[str] = None
    summary: Optional[str] = None
    episode: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        d = super().to_dict()
        d["id"] = self.id
        d["subject"] = self.subject
        d["summary"] = self.summary
        d["episode"] = self.episode
        return d


@dataclass
class EventLog(BaseMemory):
    """Event log - atomic facts extracted from MemCell/conversation."""

    time: Optional[str] = None
    atomic_fact: Optional[Union[str, List[str]]] = None
    fact_embeddings: Optional[List[List[float]]] = None
    parent_type: Optional[str] = None
    parent_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        d = super().to_dict()
        if self.time:
            d["time"] = self.time
        if self.atomic_fact:
            d["atomic_fact"] = self.atomic_fact
        if self.fact_embeddings:
            d["fact_embeddings"] = self.fact_embeddings
        d["parent_type"] = self.parent_type
        if self.parent_id:
            d["parent_id"] = self.parent_id
        return d

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "EventLog":
        """Create from dictionary."""
        return cls(
            memory_type=MemoryType.from_string(data.get("memory_type")),
            user_id=data.get("user_id", ""),
            timestamp=data.get("timestamp"),
            ori_event_id_list=data.get("ori_event_id_list", []),
            time=data.get("time", ""),
            atomic_fact=data.get("atomic_fact", []),
            fact_embeddings=data.get("fact_embeddings"),
            parent_type=data.get("parent_type"),
            parent_id=data.get("parent_id"),
        )


@dataclass
class Foresight(BaseMemory):
    """Foresight prediction memory extracted from MemCell/conversation."""

    foresight: Optional[str] = None
    evidence: Optional[str] = None
    start_time: Optional[str] = None
    end_time: Optional[str] = None
    duration_days: Optional[int] = None
    parent_type: Optional[str] = None
    parent_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        d = super().to_dict()
        d["foresight"] = self.foresight
        d["evidence"] = self.evidence
        d["start_time"] = self.start_time
        d["end_time"] = self.end_time
        d["duration_days"] = self.duration_days
        d["parent_type"] = self.parent_type
        d["parent_id"] = self.parent_id
        return d
